//=== OiInstTranslate.h - Convert Oi MCInst to LLVM IR -*- C++ -*-==//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This class translates a Oi MCInst to LLVM IR using static binary translation
// techniques.
//
//===----------------------------------------------------------------------===//

#ifndef OIINSTTRANSLATE_H
#define OIINSTTRANSLATE_H
#include "llvm/MC/MCInstPrinter.h"
#include "llvm/Object/ObjectFile.h"
#include "InstPrinter/OiInstPrinter.h"
#include "llvm/ADT/OwningPtr.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"

namespace llvm {

namespace object{
class ObjectFile;
}

using namespace object;

class OiInstTranslate : public MCInstPrinter {
public:
  OiInstTranslate(const MCAsmInfo &MAI, const MCInstrInfo &MII,
                  const MCRegisterInfo &MRI, const ObjectFile *obj,
                  uint64_t Stacksz)
    : MCInstPrinter(MAI, MII, MRI),
      TheModule(new Module("outputtest", getGlobalContext())),
      Builder(getGlobalContext()), Obj(obj), Regs(SmallVector<Value*,67>(67)),
      GlobalRegs(SmallVector<Value*,67>(67)),
      FirstFunction(true), CurAddr(0), CurSection(0), BBMap(), InsMap(),
      ReadMap(), WriteMap(), FunctionCallMap(), FunctionRetMap(),
      CurFunAddr(0), CurBlockAddr(0), StackSize(Stacksz)
  {
    BuildShadowImage();
    BuildRegisterFile();
  }

  // Autogenerated by tblgen.
  void printInstruction(const MCInst *MI, raw_ostream &O);
  static const char *getRegisterName(unsigned RegNo);

  virtual void printRegName(raw_ostream &OS, unsigned RegNo) const;
  virtual void printInst(const MCInst *MI, raw_ostream &O, StringRef Annot);
  void printCPURegs(const MCInst *MI, unsigned OpNo, raw_ostream &O);

  bool printAliasInstr(const MCInst *MI, raw_ostream &OS);
  Module* takeModule();
  void StartFunction(Twine &N);
  void FixBBTerminators();
  void FinishFunction();
  void FinishModule();
  void UpdateCurAddr(uint64_t val) {
    CurAddr = val;
    UpdateInsertPoint();
  }
  void SetCurSection(section_iterator *i) {
    CurSection = i;
  }

private:
  OwningPtr<Module> TheModule;
  IRBuilder<> Builder;
  const ObjectFile *Obj;
  OwningArrayPtr<uint8_t> ShadowImage;
  uint64_t ShadowSize;
  SmallVector<Value*, 67> Regs, GlobalRegs;
  Value* ShadowImageValue;
  bool FirstFunction;
  uint64_t CurAddr;
  section_iterator* CurSection;
  StringMap<BasicBlock*> BBMap;
  DenseMap<int64_t, Instruction*> InsMap;
  DenseMap<int32_t, bool> ReadMap, WriteMap;
  DenseMap<int32_t, int32_t> FunctionCallMap; // Used only in one-region mode
  DenseMap<int32_t, int32_t> FunctionRetMap; // Used only in one-region mode
  uint64_t CurFunAddr;
  uint64_t CurBlockAddr;
  uint64_t StackSize;

  bool HandleAluSrcOperand(const MCOperand &o, Value *&V);
  bool HandleAluDstOperand(const MCOperand &o, Value *&V);
  bool HandleMemExpr(const MCExpr &exp, Value *&V, bool IsLoad);
  bool HandleMemOperand(const MCOperand &o, const MCOperand &o2, Value *&V,
                        Value **First, bool IsLoad, int width = 32);
  bool HandleDoubleMemOperand(const MCOperand &o, const MCOperand &o2,
                              Value *&V1, Value *&V2, Value **First, bool IsLoad);
  bool HandleLUiOperand(const MCOperand &o, Value *&V, Value **First, bool IsLoad);
  bool HandleCallTarget(const MCOperand &o, Value *&V, Value **First = 0);
  bool HandleFCmpOperand(const MCOperand &o, Value *o0, Value *o1, Value *&V);
  bool HandleBranchTarget(const MCOperand &o, BasicBlock *&Addr, bool IsRelative = true);
  bool HandleBackEdge(uint64_t Addr, BasicBlock *&Target);
  bool HandleSyscallWrite(Value *&V, Value **First = 0);
  bool HandleLibcAtoi(Value *&V, Value **First = 0);
  bool HandleLibcMalloc(Value *&V, Value **First = 0);
  bool HandleLibcCalloc(Value *&V, Value **First = 0);
  bool HandleLibcFree(Value *&V, Value **First = 0);
  bool HandleLibcExit(Value *&V, Value **First = 0);
  bool HandleLibcPuts(Value *&V, Value **First = 0);
  bool HandleLibcMemset(Value *&V, Value **First = 0);
  bool HandleLibcFwrite(Value *&V, Value **First = 0);
  bool HandleLibcFprintf(Value *&V, Value **First = 0);
  bool HandleLibcPrintf(Value *&V, Value **First = 0);
  bool HandleLibcScanf(Value *&V, Value **First = 0);
  bool HandleLocalCallOneRegion(uint64_t Addr, Value *&V, Value **First = 0);
  SmallVector<uint32_t, 4> GetCallSitesFor(uint32_t FuncAddr);
  bool BuildReturnTablesOneRegion();
  bool HandleLocalCall(uint64_t Addr, Value *&V, Value **First = 0);
  Value *AccessShadowMemory32(Value *Idx, bool IsLoad, int width = 32);
  bool CheckRelocation(relocation_iterator &Rel, StringRef &Name);
  bool ResolveRelocation(uint64_t &Res, uint64_t *Type = 0);
  void InsertStartupCode();
  BasicBlock* CreateBB(uint64_t Addr = 0, Function *F = 0);
  void UpdateInsertPoint();
  bool HandleSaveDouble(Value *In, Value *&Out1, Value *&Out2);
  bool HandleDoubleSrcOperand(const MCOperand &o, Value *&V, Value **First = 0);
  bool HandleDoubleDstOperand(const MCOperand &o, Value *&V1, Value *&V2);

  void printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O);
  void printUnsignedImm(const MCInst *MI, int opNum, raw_ostream &O);
  void printMemOperand(const MCInst *MI, int opNum, raw_ostream &O);
  void printMemOperandEA(const MCInst *MI, int opNum, raw_ostream &O);
  void printFCCOperand(const MCInst *MI, int opNum, raw_ostream &O);
  void BuildShadowImage();
  void BuildRegisterFile();
  void BuildLocalRegisterFile();
  void HandleFunctionEntryPoint(Value **First = 0);
  void HandleFunctionExitPoint(Value **First = 0);
  void CleanRegs();
};
} // end namespace llvm

#endif
